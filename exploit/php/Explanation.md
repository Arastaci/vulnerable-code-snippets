# Contents

- [WeakCryptography.php](#weakcryptographyphp)
- [SQLInjection.php](#sqlinjectionphp)
- [HeaderInjection.php](#headerinjectionphp)
- [ArbitraryFileRead.php](#arbitraryfilereadphp)

&nbsp;

## [WeakCryptography.php](../../examples/insecure/php/WeakCryptography.php)

Path: `/examples/insecure/php/WeakCryptography.php`

### Explanation

At first glance, you might expect a classic SQL Injection vulnerability, but there is no SQLi on line 8. However, if you examine line 27, you will notice a vulnerability where the server-generated token can be predicted. This involves the `changePassword` and `generatePasswordResetToken` functions. These functions are responsible for generating tokens, but they fail to use a cryptographically secure pseudorandom number generator (CSPRNG).

For secure token generation, it is essential to use a cryptographically secure random generator. If the server generates a token at time T, it must use a secure method to ensure the token cannot be predicted.

The server's time can be retrieved via a simple curl request, such as:
```bash
curl https://example.com/ --head
```
While the server's time and the local time obtained with the `date` command are not necessarily synchronized, the server's time can still be a critical factor for an attacker.

### Attack Vector
Suppose you are targeting a specific user, e.g., `victim@gmail.com`. To exploit this vulnerability, you can force the system to generate a token for that user (e.g., via email or SMS). By analyzing the server's behavior and predicting the generated token, you may potentially bypass authentication or perform other malicious actions.

### Note
The use of MD5 alone does not inherently make a system insecure.

&nbsp;


## [SQLInjection.php](../../examples/insecure/php/SQLInjection.php)

Path: `/examples/insecure/php/SQLInjection.php`

### Explanation

In this example, the vulnerability lies in line 8, where the `mail` variable is directly used in the SQL query on line 19 without proper sanitization or validation. The goal is to craft a payload to bypass PHP validators and execute an SQL injection.

### How to Construct a Payload?

To exploit the SQLi vulnerability, you need to use a single quote (`'`) as seen on line 19. However, line 10 does not properly validate the presence of single quotes in the email input, meaning you can include single quotes in the email address.

#### Step-by-Step Payload Construction:

1. **Start with a Valid Email**  
   A valid email is required as a base. For example:  
    - test@test.com

2. **Insert a Single Quote**  
A single quote cannot be placed after the `@` symbol because it is invalid in the domain part of an email address. However, it can be placed before the `@`:  

    - 'test@test.com

3. **Comment Out the Remaining Query**  
To prevent syntax errors, the remaining part of the query needs to be commented out. This can be achieved with `--`:  
    - 'test--@test.com

4. **Construct the Exploit**  
Use `UNION SELECT` to retrieve data, replacing spaces with `/**/` for better compatibility. For example:  
    - '/** /UNION/** /SELECT/** /table_name/** /FROM/** /information_schema.tables/** /test--@test.com

5. **Refine the Payload**  
After discovering the table and column names, construct the final payload to extract data:  

    ### Final Query:
    The final SQL query executed by the server becomes:
    ```sql
    SELECT username FROM users WHERE email=''/**/UNION/**/SELECT/**/password/**/FROM/**/users/**/--'@test.com' LIMIT 1
    ```
This query retrieves the password column from the users table by exploiting the SQL injection vulnerability.

&nbsp;

## [HeaderInjection.php](../../examples/insecure/php/HeaderInjection.php)

Path: `/examples/insecure/php/HeaderInjection.php`

### Explanation

In applications behind load balancers, developers often rely on the `X-Forwarded-For` header to determine the real IP address of the client since the TCP source address typically points to the load balancer itself. However, improper validation or misconfigurations can lead to security vulnerabilities.

- **Issue on Line 9**:  
  The validation applied to the header value is insufficient. Specifically, `X-Forwarded-For` values are not properly sanitized or validated.

- **Issue on Line 15**:  
  The developer forgot to use `exit()` or `die()` after printing an error message. As a result, the interpreter continues execution, eventually reaching the vulnerable `call_user_func` function on Line 19.

#### Exploit:

By crafting a malicious payload, you can bypass the validation and achieve remote code execution via the `call_user_func` method. 

Payload example: 

```bash
curl -H "X-Forwarded-For:127::1" "http://target.com/?cmd=system&arg=netcatreverseshell"

curl -H "X-Forwarded-For:127::1" "http://target.com/?cmd=exec&arg='command_here'"
``` 

1. On Line 9, the payload bypasses weak validation checks for X-Forwarded-For. The payload constructed with oketet syntax for better compatibility.
2. Since no exit() is called on Line 13, execution flows to Line 19.
3. `call_user_func` executes the function specified in the cmd query parameter (system) with the argument arg.

&nbsp;

## [ArbitraryFileRead.php](../../examples/insecure/php/ArbitraryFileRead.php)

Path: `/examples/insecure/php/ArbitraryFileRead.php`

### Explanation

The `debugCertificate()` function directly passes the user-supplied `cert` parameter to OpenSSL functions:

- **Issue:**  
  PHP's OpenSSL functions (openssl_pkey_get_public, openssl_pkey_get_private) accept the parameter as either **PEM-encoded data** or a **file path with the `file://` prefix**.  
  An attacker can use file:// to read sensitive files on the server.


An attacker sends a request with a malicious cert parameter:

```http
POST /debug.php HTTP/1.1
...
cert=file:///key.pem
```

openssl_pkey_get_public interprets /key.pem as a file and reads its content. The fileâ€™s content is then passed to openssl_pkey_get_details, serialized, and displayed in the response. If /key.pem contains a private key or certificate, the attacker can retrieve it.

&nbsp;