# Contents

- [CaseInsensitive.js](#caseinsensitivejs)
- [DomXss.vue](#domxssvue)
- [oauth-bypass.html](#oauth-bypasshtml)


## [CaseInsensitive.js](../../examples/insecure/js/CaseInsensitive.js)
Path: `/examples/insecure/js/CaseInsensitive.js`

### Explanation
The issue arises because the `startsWith` method is **not case-sensitive**. This means that requests like `/api` or `/ApI` can bypass authentication checks. 

The vulnerability is introduced on line 6:  
- If the path starts with `/api`, an authentication check is performed (line 7).  
- However, if the path does not start with `/api`, the code skips authentication and moves directly to the `next` function (line 13).  
- If a payload like `target.com/./ApI` is provided:  
1. The `next` function normalizes the path.  
2. Since there is no self-loop or further validation, the request bypasses all authentication and is processed without any checks.

&nbsp;

## [DomXss.vue](../../examples/insecure/js/DomXss.vue)

Path: `/examples/insecure/js/DomXss.vue`

### Explanation

The data comes from Vue Router where `$route` represents the current URL. Depending on the routing mode, `$route.query` either comes from the current URL's query parameters or from the URL's hash portion and we could now inject arbitrary attributes into the `PageContent` component, including JavaScript event handlers.

#### Exploit:

The spinner animation defined in the CSS section of the code snippet is useful. Since the animation is already defined, it can be harnessed in a `style` attribute and arbitrary JavaScript can be inserted into the `onanimationstart` event handler. When the page loads, the animation starts, triggering the event handler and executing the injected JavaScript.

The final malicious URL looks like this:

```bash
http://site.com/#/?style=animation-name:spinner&onanimationstart=alert(1)
```

&nbsp;

## [oauth-bypass.html](../../examples/insecure/js/oauth-bypass.html)

Path: `/examples/insecure/js/oauth-bypass.html`

### Explanation

### Improper Origin Validation

A popup window communicates with the main application via **window.postMessage** to handle GitHub OAuth authentication. The security of incoming messages is ensured by two checks:

```javascript
window.addEventListener('message', ({ source, origin, data }) => {
  if (source !== window.opener) return; // Only accept messages from the opener
  if (origin !== window.origin) return; // Origin check
});
```

- **Issue:** `window.origin` does not represent the source of the popup.  
  - Due to **sandboxing effects**, `window.origin` may become **null**.
  - If an attacker sends messages with **null origin**, the validation is bypassed.

### **Stealing OAuth Authorization Code**
#### **Host Malicious Page in a Sandbox Iframe**
The attacker embeds a malicious page inside an iframe with **sandbox** attributes:

```html
<iframe sandbox="allow-scripts allow-popups" src="data:text/html,..."></iframe>
```
- The **window.origin** of both the iframe and the popup is **null**.

#### **Open the OAuth Popup with Null Origin**
The malicious iframe launches an OAuth popup:

```javascript
const victimWindow = window.open('http://target-site/oauth-popup.html', ...);
```

- The popup's **window.origin is set to null** due to the sandbox environment.

#### **Bypass Message Validation**
The attacker sends a command to the popup with **null origin**:

```javascript
victimWindow.postMessage({ cmd: 'startAuthFlow', args: [clientId] }, '*');
```

- In the popup's message listener:
  - `origin !== window.origin` check becomes `null === null`, so the validation passes.

#### **Extract the OAuth Authorization Code**
Once GitHub redirects the user to the OAuth popup, the attacker extracts the `code` parameter from the URL:

```javascript
victimWindow.postMessage({ cmd: 'getAuthCode' }, '*');
// Popup responds with: { type: 'auth-code', code: '...' }
```

- Since `origin` is null, the popup mistakenly trusts the attacker.

### **Recommendation**
#### **Use `location.origin` Instead of `window.origin`:**
Modify the message validation to use `location.origin`:

```javascript
if (origin !== location.origin) return; // Validate against the actual origin
```

**Why?** `location.origin` is **not affected by sandboxing** and always reflects the true origin (e.g., `http://target-site:port`).

&nbsp;